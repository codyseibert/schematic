(function() {
  var CSONParser, crypto, csonVersion, getCachePath, path, readFromCache, writeToCache, _;

  crypto = require('crypto');

  path = require('path');

  _ = require('underscore-plus');

  CSONParser = require('cson-parser');

  csonVersion = require('cson-parser/package.json').version;

  getCachePath = function(source, options) {
    var cachePath, folderName, rootObject, sha1;
    if (options == null) {
      options = {};
    }
    rootObject = options.rootObject, cachePath = options.cachePath;
    if (!cachePath) {
      return null;
    }
    sha1 = crypto.createHash('sha1').update(source, 'utf8').digest('hex');
    if (rootObject) {
      folderName = "" + csonVersion + "-require-root";
    } else {
      folderName = csonVersion;
    }
    return path.join(cachePath, folderName, "" + sha1 + ".json");
  };

  readFromCache = function(grunt, fileCachePath) {
    var error;
    try {
      return grunt.file.read(fileCachePath, 'utf8');
    } catch (_error) {
      error = _error;
      return null;
    }
  };

  writeToCache = function(grunt, fileCachePath, json) {
    try {
      return grunt.file.write(fileCachePath, json);
    } catch (_error) {}
  };

  module.exports = function(grunt) {
    return grunt.registerMultiTask('cson', 'Compile CSON files to JSON', function() {
      var compileFailure, fileCount, options, rootObject;
      options = this.options();
      rootObject = options.rootObject;
      if (rootObject == null) {
        rootObject = false;
      }
      fileCount = 0;
      compileFailure = false;
      this.files.forEach(function(_arg) {
        var content, dest, end, error, errorLine, fileCachePath, json, lineNumber, lines, location, message, source, sourceData, src, start, _i;
        src = _arg.src, dest = _arg.dest;
        source = src[0];
        try {
          sourceData = grunt.file.read(source, 'utf8');
          fileCachePath = getCachePath(sourceData, options);
          if (fileCachePath) {
            json = readFromCache(grunt, fileCachePath);
          }
          if (json == null) {
            content = CSONParser.parse(sourceData);
            if (rootObject && (!_.isObject(content) || _.isArray(content))) {
              grunt.log.error("" + source.yellow + " does not contain a root object.");
              return;
            }
            json = "" + (JSON.stringify(content, null, 2)) + "\n";
            if (fileCachePath) {
              writeToCache(grunt, fileCachePath, json);
            }
          }
          grunt.file.write(dest, json);
          fileCount++;
          grunt.verbose.writeln("File " + dest.cyan + " created.");
        } catch (_error) {
          error = _error;
          compileFailure = true;
          grunt.log.writeln("Parsing " + source.yellow + " failed.");
          message = error.message, location = error.location;
          if (!message) {
            message = 'Unknown error';
          }
          grunt.log.error(message.red);
          if (location != null) {
            start = location.first_line;
            end = location.last_line;
            lines = sourceData.split('\n');
            for (lineNumber = _i = start; start <= end ? _i <= end : _i >= end; lineNumber = start <= end ? ++_i : --_i) {
              errorLine = lines[lineNumber];
              if (errorLine == null) {
                continue;
              }
              grunt.log.error("" + (lineNumber + 1) + ": " + lines[lineNumber]);
            }
          }
        }
      });
      grunt.log.ok("" + fileCount + " " + (grunt.util.pluralize(fileCount, 'file/files')) + " compiled to JSON.");
      if (this.compileFailure) {
        return false;
      }
    });
  };

}).call(this);
